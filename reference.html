<!DOCTYPE html>
<html lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
        <meta name="description" content="The Lily Programming Language, reference">
        <meta name="author" content="Jesse Ray Adkins">

        <title>Lily Language Reference</title>

        <!-- Bootstrap core CSS -->
        <link href="css/bootstrap.min.css" rel="stylesheet">
        <!-- Bootstrap theme -->
        <link href="css/bootstrap-theme.min.css" rel="stylesheet">
        <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
        <link href="css/ie10-viewport-bug-workaround.css" rel="stylesheet">

        <link rel="stylesheet" href="css/theme.css">
        <link rel="stylesheet" href="css/doc.css">

        <script src="js/ie-emulation-modes-warning.js"></script>
    </head>

    <body role="document">
        <nav class="navbar navbar-inverse navbar-static-top">
            <div class="container">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="index.html">Lily</a>
                </div>

                <div id="navbar" class="navbar-collapse collapse">
                        <ul class="nav navbar-nav">
                            <li><a href="index.html">Home</a></li>
                            <li><a href="tutorial.html">Tutorial</a></li>
                            <li class="active"><a href="#">Reference</a></li>
                            <li><a href="packages.html">Packages</a></li>
                            <li><a href="sandbox.html">Sandbox</a></li>
                            <li><a href="http://github.com/jesserayadkins/lily">Github</a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </nav>

        <div class="container theme-showcase" role="main">
<h1>builtin</h1>
<p>The builtin package provides the classes, vars, and functions that form the
foundation of Lily.</p>
<h5><span class="funcname">print</span><span><strong>[A](value: A)</strong></span></h5>

<div class="explain">Attempt to write <span class="varname">value</span> to <span class="varname">stdout</span>, including a terminating newline.
<br />
Errors:
<br />
Raises <span class="type">IOError</span> if <span class="varname">stdout</span> is closed or not open for writing.</div>
<h5><span class="funcname">calltrace</span><span><strong>: List[String]</strong></span></h5>

<div class="explain">Returns a <span class="type">List</span> with one <span class="type">String</span> for each function that is currently entered.</div>

<h3>Boolean</h3>
<p>The <span class="type">Boolean</span> class represents a value that is either <span class="varname">true</span> or <span class="varname">false</span>.</p>
<h5><span class="funcname">Boolean.to_i</span><span><strong>(self: Boolean): Integer</strong></span></h5>

<div class="explain">Convert a <span class="type">Boolean</span> to an <span class="type">Integer</span>. <span class="varname">true</span> becomes <span class="varname">1</span>, <span class="varname">false</span> becomes <span class="varname">0</span>.</div>
<h5><span class="funcname">Boolean.to_s</span><span><strong>(self: Boolean): String</strong></span></h5>

<div class="explain">Convert a <span class="type">Boolean</span> to a <span class="type">String</span>.</div>

<h3>ByteString</h3>
<p>The <span class="type">ByteString</span> class represents a bag of bytes. A <span class="type">ByteString</span> may have <span class="varname">\0</span>
values embedded within it. It may also have data that is not valid as utf-8.
The <span class="type">ByteString</span> class currently does not support any primitive operations.</p>
<h5><span class="funcname">ByteString.encode</span><span><strong>(self: ByteString, encode: *String="error"): Option[String]</strong></span></h5>

<div class="explain">Attempt to transform the given <span class="type">ByteString</span> into a <span class="type">String</span>. The action taken
depends on the value of <span class="varname">encode</span>.
<br />
If encode is <span class="varname">"error"</span>, then invalid utf-8 or embedded <span class="varname">\0</span> values within <span class="type">self</span>
will result in <span class="varname">None</span>.</div>

<h3>Double</h3>
<p>The <span class="type">Double</span> class exists as a wrapper over a C double.</p>
<h5><span class="funcname">Double.to_i</span><span><strong>(self: Double): Integer</strong></span></h5>

<div class="explain">Convert a <span class="type">Double</span> to an <span class="type">Integer</span>. This is done internally through a cast from
a C double, to int64_t, the type of <span class="type">Integer</span>.</div>

<h3>Dynamic</h3>
<p>The <span class="type">Dynamic</span> class allows defering type checking until runtime. Creation of
<span class="type">Dynamic</span> is done through <span class="varname">Dynamic(&lt;value&gt;)</span>. Extraction of values is done
through a cast: <span class="varname">.@(type)</span>. The result of a cast is <span class="type">Option[&lt;type&gt;]</span>, with
<span class="varname">Some</span> on success and <span class="varname">None</span> on failure. Finally, casts are not allowed to hold
polymorphic types, such as <span class="type">List</span> or <span class="type">Hash</span> or <span class="type">Function</span>, because Lily's vm
only holds class information at runtime.</p>
<h5><span class="funcname">Dynamic.new</span><span><strong>[A](self: A): Dynamic</strong></span></h5>

<div class="explain">Constructs a new <span class="type">Dynamic</span> value. This method exists as a convenience to allow
a shorthand constructor (<span class="varname">Dynamic(&lt;value&gt;)</span>).
<br />
While it is currently possible to place polymorphic values into <span class="type">Dynamic</span>, that
ability will be removed in the future, as it is not possible to cast polymorphic
values out of a <span class="type">Dynamic</span>.</div>

<h3>Either</h3>
<p>The <span class="type">Either</span> enum can be usd to represent an operation that may or may not
succeed. Unlike <span class="type">Option</span>, <span class="type">Either</span> provides <span class="type">Left</span> which may be used to hold a
useful error message in the event of a failure.
</p>
<h5><span class="funcname">Either.is_left</span><span><strong>[A, B](self: Either[A, B]): Boolean</strong></span></h5>

<div class="explain">Return <span class="varname">true</span> if <span class="varname">self</span> contains a <span class="varname">Left</span>, <span class="varname">false</span> otherwise.</div>
<h5><span class="funcname">Either.is_right</span><span><strong>[A, B](self: Either[A, B]): Boolean</strong></span></h5>

<div class="explain">Return <span class="varname">true</span> if <span class="varname">self</span> contains a <span class="varname">Right</span>, <span class="varname">false</span> otherwise.</div>
<h5><span class="funcname">Either.left</span><span><strong>[A, B](self: Either[A, B]):Option[A]</strong></span></h5>

<div class="explain">If <span class="varname">self</span> contains a <span class="varname">Left</span>, produces a <span class="varname">Some(A)</span>.
<br />
If <span class="varname">self</span> contains a <span class="varname">Right</span>, produces <span class="varname">None</span>.</div>
<h5><span class="funcname">Either.right</span><span><strong>[A, B](self: Either[A, B]): Option[B]</strong></span></h5>

<div class="explain">If <span class="varname">self</span> contains a <span class="varname">Left</span>, produces a <span class="varname">None</span>.
<br />
If <span class="varname">self</span> contains a <span class="varname">Right</span>, produces <span class="varname">Right(B)</span>.</div>

<h3>Exception</h3>
<p>The <span class="type">Exception</span> class is the base class of all exceptions. The following
children are also defined:
<br />
<span class="type">DivisionByZeroError</span> is raised when trying to divide or modulo by zero.
<br />
<span class="type">IndexError</span> is raised when an out-of-bounds access is performed on a <span class="type">List</span>.
<br />
<span class="type">IOError</span> is raised when an IO operation fails or does not have permission.
<br />
<span class="type">KeyError</span> is raised when trying to get an item from a <span class="type">Hash</span> that does not
exist.
<br />
<span class="type">RuntimeError</span> is raised when the recursion limit is exceeded, or when trying
to modify a <span class="type">Hash</span> while iterating over it.
<br />
<span class="type">ValueError</span> is raised when sending an improper argument to a function, such as
trying to call <span class="varname">List.fill</span> with a negative amount.</p>

<h3>File</h3>
<p>The <span class="type">File</span> class provides a wrapper over a C FILE * struct. A <span class="type">File</span> is closed
automatically when a scope exits (though not immediately). However, it is also
possible to manually close a <span class="type">File</span>.</p>
<h5><span class="funcname">File.close</span><span><strong>(self: File)</strong></span></h5>

<div class="explain">Close <span class="varname">self</span> if it is open, or do nothing if already closed.
<br />
For standard streams, this marks the <span class="type">File</span> as closed, but does not actually
close the stream. Embedders, therefore, do not need to worry about standard
streams being altered or closed by Lily.</div>
<h5><span class="funcname">File.open</span><span><strong>(path: String, mode: String):File</strong></span></h5>

<div class="explain">Attempt to open <span class="varname">path</span> using the <span class="varname">mode</span> given. <span class="varname">mode</span> may be one of the
following:
<br />
<span class="varname">"r"</span> (readonly, must exist)
<br />
<span class="varname">"w"</span> (writeonly)
<br />
<span class="varname">"a"</span> (append, create if not exist)
<br />
<span class="varname">"r+"</span> (read+write, must exist)
<br />
<span class="varname">"w+"</span> (read+write, creates an empty file if needed)
<br />
<span class="varname">"a+"</span> (read+append)
<br />
Errors:
<br />
If unable to open <span class="varname">path</span>, or an invalid <span class="varname">mode</span> is provided, <span class="type">IOError</span> is raised.</div>
<h5><span class="funcname">File.print</span><span><strong>[A](self: File, data: A)</strong></span></h5>

<div class="explain">Attempt to write the contents of <span class="varname">data</span> to the file provided. <span class="varname">data</span> is written
with a newline at the end.
<br />
Errors:
<br />
If <span class="varname">self</span> is closed or is not open for writing, <span class="type">IOError</span> is raised.</div>
<h5><span class="funcname">File.read_line</span><span><strong>(self: File): ByteString</strong></span></h5>

<div class="explain">Attempt to read a line of text from <span class="varname">self</span>. Currently, this function does not
have a way to signal that the end of the file has been reached. For now, callers
should check the result against <span class="varname">B""</span>. This will be fixed in a future release.
<br />
Errors:
<br />
If <span class="varname">self</span> is not open for reading, or is closed, <span class="type">IOError</span> is raised.</div>
<h5><span class="funcname">File.write</span><span><strong>[A](self: File, data: A)</strong></span></h5>

<div class="explain">Attempt to write the contents of <span class="varname">data</span> to the file provided.
<br />
Errors:
<br />
If <span class="varname">self</span> is closed or is not open for writing, <span class="type">IOError</span> is raised.</div>

<h3>Function</h3>
<p>The <span class="type">Function</span> class represents a block of code to be called, which may or may
not produce a value. <span class="type">Function</span> values are first-class, and can be passed around
as arguments, placed into a <span class="type">List</span>, and so on.
<br />
The arguments of a <span class="type">Function</span> are denoted within parentheses, with an optional
colon at the end to denote the value returned:
<br />
<span class="type">Function(Integer): String</span> (return <span class="type">String</span>).
<br />
<span class="type">Function(String, String)</span> (no value returned).</p>

<h3>Hash</h3>
<p>The <span class="type">Hash</span> class provides a mapping between a key and a value. <span class="type">Hash</span> values can
be created through <span class="varname">[key1 =&gt; value1, key2 =&gt; value2, ...]</span>. When writing a
<span class="type">Hash</span>, the key is the first type, and the value is the second.
<br />
<span class="varname">[1 =&gt; "a", 2 =&gt; "b", 3 =&gt; "c"]</span> would therefore be written as
<span class="type">Hash[Integer, String]</span>.
<br />
Currently, only <span class="type">Integer</span> and <span class="type">String</span> can be used as keys.</p>
<h5><span class="funcname">Hash.clear</span><span><strong>[A, B](self: Hash[A, B])</strong></span></h5>

<div class="explain">Removes all pairs currently present within <span class="varname">self</span>. No error occurs if <span class="varname">self</span> is
currently being iterated over.</div>
<h5><span class="funcname">Hash.delete</span><span><strong>[A, B](self: Hash[A, B], key: A)</strong></span></h5>

<div class="explain">Attempt to remove <span class="varname">key</span> from <span class="varname">self</span>. If <span class="varname">key</span> is not present within <span class="varname">self</span>, then
nothing happens.
<br />
Errors:
<br />
If <span class="varname">self</span> is currently being iterated over, <span class="type">RuntimeError</span> will be raised.</div>
<h5><span class="funcname">Hash.each_pair</span><span><strong>[A, B](self: Hash[A, B], fn: Function(A, B))</strong></span></h5>

<div class="explain">Iterate through each pair that is present within <span class="varname">self</span>. For each of the pairs,
call <span class="varname">fn</span> with the key and value of each pair.</div>
<h5><span class="funcname">Hash.get</span><span><strong>[A, B](self: Hash[A, B], key: A, default: B): B</strong></span></h5>

<div class="explain">Attempt to find <span class="varname">key</span> within <span class="varname">self</span>. If <span class="varname">key</span> is present, then the value
associated with it is returned. If <span class="varname">key</span> cannot be found, then <span class="varname">default</span> is
returned instead.</div>
<h5><span class="funcname">Hash.has_key</span><span><strong>[A, B](self: Hash[A, B], key: A):Boolean</strong></span></h5>

<div class="explain">Return <span class="varname">true</span> if <span class="varname">key</span> is present within <span class="varname">self</span>, <span class="varname">false</span> otherwise.</div>
<h5><span class="funcname">Hash.keys</span><span><strong>[A, B](self: Hash[A, B]): List[A]</strong></span></h5>

<div class="explain">Construct a <span class="type">List</span> containing all values that are present within <span class="varname">self</span>. There
is no guarantee of the ordering of the resulting <span class="type">List</span>.</div>
<h5><span class="funcname">Hash.map_values</span><span><strong>[A, B, C](self: Hash[A, B], Function(B => C)): Hash[A, C]</strong></span></h5>

<div class="explain">This iterates through <span class="varname">self</span> and calls <span class="varname">fn</span> for each element present. The result
of this function is a newly-made <span class="type">Hash</span> where each value is the result of the
call to <span class="varname">fn</span>.</div>
<h5><span class="funcname">Hash.merge</span><span><strong>[A, B](self: Hash[A, B], others: Hash[A, B]...): Hash[A, B]</strong></span></h5>

<div class="explain">Create a new <span class="type">Hash</span> that holds the result of <span class="varname">self</span> and each `Hash present
within <span class="varname">others</span>.
<br />
When duplicate elements are found, the value of the right-most <span class="type">Hash</span> wins.</div>
<h5><span class="funcname">Hash.reject</span><span><strong>[A, B](self: Hash[A, B], fn: Function(A, B => Boolean)): Hash[A, B]</strong></span></h5>

<div class="explain">This calls <span class="varname">fn</span> for each element present within <span class="varname">self</span>. The result of this
function is a newly-made <span class="type">Hash</span> containing all values for which <span class="varname">fn</span> returns
<span class="varname">false</span>.</div>
<h5><span class="funcname">Hash.select</span><span><strong>[A, B](self: Hash[A, B], fn: Function(A, B => Boolean)): Hash[A, B]</strong></span></h5>

<div class="explain">This calls <span class="varname">fn</span> for each element present within <span class="varname">self</span>. The result of this
function is a newly-made <span class="type">Hash</span> containing all values for which <span class="varname">fn</span> returns
<span class="varname">true</span>.</div>
<h5><span class="funcname">Hash.size</span><span><strong>[A, B](self: Hash[A, B]): Integer</strong></span></h5>

<div class="explain">Returns the number of key+value pairs present within <span class="varname">self</span>.</div>

<h3>Integer</h3>
<p>The <span class="type">Integer</span> class is Lily's native numeric type. Internally, it is a wrapper
over a C int64_t.</p>
<h5><span class="funcname">Integer.to_d</span><span><strong>(self: Integer): Double</strong></span></h5>

<div class="explain">Converts an <span class="type">Integer</span> to a <span class="type">Double</span>. Internally, this is done by a typecast to
the <span class="type">Double</span> type (a raw C double).</div>
<h5><span class="funcname">Integer.to_s</span><span><strong>(self: Integer): String</strong></span></h5>

<div class="explain">Convert an <span class="type">Integer</span> to a <span class="type">String</span> using base-10.</div>

<h3>List</h3>
<p>The <span class="type">List</span> class represents a container of a given type, written as
<span class="type">List[&lt;inner type&gt;]</span>. A <span class="type">List</span> value can be accessed through a positive index or
a negative one (with negative indexes being an offset from the end). Attempting
to access an invalid index will produce <span class="type">IndexError</span>.</p>
<h5><span class="funcname">List.clear</span><span><strong>[A](self: List[A])</strong></span></h5>

<div class="explain">Removes all elements present within <span class="varname">self</span>. No error is raised if <span class="varname">self</span> is
being iterated over.</div>
<h5><span class="funcname">List.count</span><span><strong>[A](self: List[A], fn: Function(A => Boolean)): Integer</strong></span></h5>

<div class="explain">This calls <span class="varname">fn</span> for each element within <span class="varname">self</span>. The result of this function is
the number of times that <span class="varname">fn</span> returns 'true.</div>
<h5><span class="funcname">List.delete_at</span><span><strong>[A](self: List[A], index: Integer)</strong></span></h5>

<div class="explain">Attempts to remove index from the List. If index is negative, then it is
considered an offset from the end of the List.
<br />
Errors:
<br />
Raises <span class="type">IndexError</span> if <span class="varname">index</span> (after adjustment) is not a valid index.</div>
<h5><span class="funcname">List.each</span><span><strong>[A](self: List[A], fn: Function(A)): List[A]</strong></span></h5>

<div class="explain">Calls <span class="varname">fn</span> for each element within <span class="varname">self</span>. The result of this function is
<span class="varname">self</span>, so that this method can be chained with others.</div>
<h5><span class="funcname">List.each_index</span><span><strong>[A](self: List[A], fn: Function(Integer)): List[A]</strong></span></h5>

<div class="explain">Calls <span class="varname">fn</span> for each element within <span class="varname">self</span>. Rather than receive the elements of
<span class="varname">self</span>, <span class="varname">fn</span> instead receives the index of each element.</div>
<h5><span class="funcname">List.fill</span><span><strong>[A](count: Integer, value: A): List[A]</strong></span></h5>

<div class="explain">This createa a new <span class="type">List</span> that contains <span class="varname">value</span> repeated <span class="varname">count</span> times.
<br />
Errors:
<br />
Raises <span class="type">ValueError</span> if <span class="varname">count</span> is less than 1.</div>
<h5><span class="funcname">List.fold</span><span><strong>[A](self: List[A], start: A, fn: Function(A, A => A)): A</strong></span></h5>

<div class="explain">This calls <span class="varname">fn</span> for each element present within <span class="varname">self</span>. The first value sent to
<span class="varname">fn</span> is initially <span class="varname">start</span>, but will later be the result of <span class="varname">fn</span>. Therefore, the
value as it accumulates can be found in the first value sent to <span class="varname">fn</span>.
<br />
The result of this function is the result of doing an accumulation on each
element within <span class="varname">self</span>.</div>
<h5><span class="funcname">List.insert</span><span><strong>[A](self: List[A], index: Integer, value: A)</strong></span></h5>

<div class="explain">Attempt to insert <span class="varname">value</span> at <span class="varname">index</span> within <span class="varname">self</span>. If index is negative, then
it is treated as an offset from the end of <span class="varname">self</span>.
<br />
Errors:
<br />
Raises <span class="type">IndexError</span> if <span class="varname">index</span> is not within <span class="varname">self</span>.</div>
<h5><span class="funcname">List.join</span><span><strong>[A](self: List[A], separator: *String=""): String</strong></span></h5>

<div class="explain">Create a <span class="type">String</span> consisting of the elements of <span class="varname">self</span> interleaved with
<span class="varname">separator</span>. The elements of self are converted to a <span class="type">String</span> as if they were
interpolated. If <span class="varname">self</span> is empty, then the result is an empty <span class="type">String</span>.</div>
<h5><span class="funcname">List.map</span><span><strong>[A,B](self: List[A], fn: Function(A => B)): List[B]</strong></span></h5>

<div class="explain">This calls <span class="varname">fn</span> on each element within <span class="varname">self</span>. The result of this function is a
newly-made <span class="type">List</span> containing the results of <span class="varname">fn</span>.</div>
<h5><span class="funcname">List.pop</span><span><strong>[A](self: List[A]): A</strong></span></h5>

<div class="explain">Attempt to remove and return the last element within <span class="varname">self</span>.
<br />
Errors:
<br />
Raises <span class="type">IndexError</span> if <span class="varname">self</span> is empty.</div>
<h5><span class="funcname">List.push</span><span><strong>[A](self: List[A], value: A)</strong></span></h5>

<div class="explain">Add <span class="varname">value</span> to the end of <span class="varname">self</span>.</div>
<h5><span class="funcname">List.reject</span><span><strong>[A](self: List[A], fn: Function(A => Boolean)): List[A]</strong></span></h5>

<div class="explain">This calls <span class="varname">fn</span> for each element within <span class="varname">self</span>. The result is a newly-made
<span class="type">List</span> holding each element where <span class="varname">fn</span> returns <span class="varname">false</span>.</div>
<h5><span class="funcname">List.select</span><span><strong>[A](self: List[A], fn: Function(A => Boolean)): List[A]</strong></span></h5>

<div class="explain">This calls <span class="varname">fn</span> for each element within <span class="varname">self</span>. The result is a newly-made
<span class="type">List</span> holding each element where <span class="varname">fn</span> returns <span class="varname">true</span>.</div>
<h5><span class="funcname">List.size</span><span><strong>[A](self: List[A]): Integer</strong></span></h5>

<div class="explain">Returns the number of elements that are within <span class="varname">self</span>.</div>
<h5><span class="funcname">List.shift</span><span><strong>[A](self: List[A]): A</strong></span></h5>

<div class="explain">This attempts to remove the last element from <span class="varname">self</span> and return it.
<br />
Errors:
<br />
Raises <span class="type">ValueError</span> if <span class="varname">self</span> is empty.</div>
<h5><span class="funcname">List.unshift</span><span><strong>[A](self: List[A], value: A)</strong></span></h5>

<div class="explain">Inserts value at the front of self, moving all other elements to the right.</div>

<h3>Option</h3>
<p>The <span class="type">Option</span> type allows a variable to hold either a value of <span class="type">A</span> or to hold
<span class="varname">None</span>, with <span class="varname">None</span> being valid for any <span class="type">Option</span>. The <span class="type">Option</span> type thus
presents a way to have a function to fail without raising an exception, among
many other uses.
</p>
<h5><span class="funcname">Option.and</span><span><strong>[A, B](self: Option[A], other: Option[B]): Option[B]</strong></span></h5>

<div class="explain">If <span class="varname">self</span> is a <span class="varname">Some</span>, this returns <span class="varname">other</span>.
<br />
Otherwise, this returns <span class="varname">None</span>.</div>
<h5><span class="funcname">Option.and_then</span><span><strong>[A, B](self: Option[A], fn: Function(A => Option[B])): Option[B]</strong></span></h5>

<div class="explain">If <span class="varname">self</span> is a <span class="varname">Some</span>, this calls <span class="varname">fn</span> with the value within the <span class="varname">Some</span>. The
result is the result of the <span class="type">Option</span> returned by <span class="varname">fn</span>.
<br />
Otherwise, this returns <span class="varname">None</span>.</div>
<h5><span class="funcname">Option.is_none</span><span><strong>[A](self: Option[A]): Boolean</strong></span></h5>

<div class="explain">If <span class="varname">self</span> is a <span class="varname">Some</span>, this returns <span class="varname">false</span>.
<br />
Otherwise, this returns <span class="varname">true</span>.</div>
<h5><span class="funcname">Option.is_some</span><span><strong>[A](self: Option[A]): Boolean</strong></span></h5>

<div class="explain">If <span class="varname">self</span> is a <span class="varname">Some</span>, this returns <span class="varname">true</span>.
<br />
Otherwise, this returns <span class="varname">false</span>.</div>
<h5><span class="funcname">Option.map</span><span><strong>[A, B](self: Option[A], fn: Function(A => B)): Option[B]</strong></span></h5>

<div class="explain">If <span class="varname">self</span> is a <span class="varname">Some</span>, this returns a <span class="varname">Some</span> holding the result of <span class="varname">fn</span>.
<br />
Otherwise, this returns <span class="varname">None</span>.</div>
<h5><span class="funcname">Option.or</span><span><strong>[A](self: Option[A], alternate: Option[A]): Option[A]</strong></span></h5>

<div class="explain">If <span class="varname">self</span> is a <span class="varname">Some</span>, this returns <span class="varname">self</span>.
<br />
Otherwise, this returns <span class="varname">alternate</span>.</div>
<h5><span class="funcname">Option.or_else</span><span><strong>[A](self: Option[A], fn: Function( => Option[A])):Option[A]</strong></span></h5>

<div class="explain">If <span class="varname">self</span> is a <span class="varname">Some</span>, this returns <span class="varname">self</span>.
<br />
Otherwise, this returns the result of calling <span class="varname">fn</span>.</div>
<h5><span class="funcname">Option.unwrap</span><span><strong>[A](self: Option[A]): A</strong></span></h5>

<div class="explain">If <span class="varname">self</span> is a <span class="varname">Some</span>, this returns the value contained within.
<br />
Errors:
<br />
Raises <span class="type">ValueError</span> if <span class="varname">self</span> is a <span class="varname">None</span>.</div>
<h5><span class="funcname">Option.unwrap_or</span><span><strong>[A](self: Option[A], alternate: A):A</strong></span></h5>

<div class="explain">If <span class="varname">self</span> is a <span class="varname">Some</span>, this returns the value with <span class="varname">self</span>.
<br />
Otherwise, this returns <span class="varname">alternate</span>.</div>
<h5><span class="funcname">Option.unwrap_or_else</span><span><strong>[A](self: Option[A], fn: Function( => A)):A</strong></span></h5>

<div class="explain">If <span class="varname">self</span> is a <span class="varname">Some</span>, this returns the value with <span class="varname">self</span>.
<br />
Otherwise, this returns the result of calling <span class="varname">fn</span>.</div>

<h3>String</h3>
<p>The <span class="type">String</span> class provides a wrapper over a C char *. The <span class="type">String</span> class is
guaranteed to have a single <span class="varname">\0</span> terminator. Additionally, a <span class="type">String</span> is
guaranteed to always be valid utf-8.
<br />
The methods on the <span class="type">String</span> class treat the underlying <span class="type">String</span> as being
immutable, and thus always create a new <span class="type">String</span> instead of modifying the
existing one.</p>
<h5><span class="funcname">String.ends_with</span><span><strong>(self: String, end: String): Boolean</strong></span></h5>

<div class="explain">Checks if <span class="varname">self</span> ends with <span class="varname">end</span>.</div>
<h5><span class="funcname">String.find</span><span><strong>(self: String, needle: String): Option[Integer]</strong></span></h5>

<div class="explain">Check for <span class="varname">needle</span> being within 'self.
<br />
If <span class="varname">needle</span> is found, the result is a <span class="varname">Some</span> holding the index.
<br />
Otherwise, this returns <span class="varname">None</span>.</div>
<h5><span class="funcname">String.html_encode</span><span><strong>(self: String): String</strong></span></h5>

<div class="explain">Check for one of <span class="varname">"&amp;"</span>, <span class="varname">"&lt;"</span>, or <span class="varname">"&gt;"</span> being within <span class="varname">self</span>.
<br />
If found, a new <span class="type">String</span> is contained with any instance of the above being
replaced by an html-safe value.
<br />
If not found, <span class="varname">self</span> is returned.</div>
<h5><span class="funcname">String.is_alnum</span><span><strong>(self: String):Boolean</strong></span></h5>

<div class="explain">Return <span class="varname">true</span> if <span class="varname">self</span> has only alphanumeric([a-zA-Z0-9]+) characters, <span class="varname">false</span>
otherwise.</div>
<h5><span class="funcname">String.is_alpha</span><span><strong>(self: String):Boolean</strong></span></h5>

<div class="explain">Return <span class="varname">true</span> if <span class="varname">self</span> has only alphabetical([a-zA-Z]+) characters, <span class="varname">false</span>
otherwise.</div>
<h5><span class="funcname">String.is_digit</span><span><strong>(self: String):Boolean</strong></span></h5>

<div class="explain">Return <span class="varname">true</span> if <span class="varname">self</span> has only digit([0-9]+) characters, <span class="varname">false</span> otherwise.</div>
<h5><span class="funcname">String.is_space</span><span><strong>(self: String):Boolean</strong></span></h5>

<div class="explain">Returns <span class="varname">true</span> if <span class="varname">self</span> has only space(" \t\r\n") characters, <span class="varname">false</span>
otherwise.</div>
<h5><span class="funcname">String.lower</span><span><strong>(self: String):String</strong></span></h5>

<div class="explain">Checks if any characters within <span class="varname">self</span> are within [A-Z]. If so, it creates a new
<span class="type">String</span> with [A-Z] replaced by [a-z]. Otherwise, <span class="varname">self</span> is returned.</div>
<h5><span class="funcname">String.lstrip</span><span><strong>(self: String, to_strip: String):String</strong></span></h5>

<div class="explain">This walks through <span class="varname">self</span> from left to right, stopping on the first utf-8 chunk
that is not found within <span class="varname">to_strip</span>. The result is a newly-made copy of self
without the elements within <span class="varname">to_strip</span> at the front.</div>
<h5><span class="funcname">String.parse_i</span><span><strong>(self: String): Option[Integer]</strong></span></h5>

<div class="explain">Attempts to convert <span class="varname">self</span> into an <span class="type">Integer</span>. Currently, <span class="varname">self</span> is parsed as a
base-10 encoded value.
<br />
If the value is a valid <span class="type">Integer</span>, then a <span class="varname">Some</span> containing the value is
returned.
<br />
Otherwise, <span class="varname">None</span> is returned.</div>
<h5><span class="funcname">String.rstrip</span><span><strong>(self: String, to_strip: String):String</strong></span></h5>

<div class="explain">This walks through <span class="varname">self</span> from right to left, stopping on the first utf-8 chunk
that is not found within <span class="varname">to_strip</span>. The result is a newly-made copy of <span class="varname">self</span>
without the elements of <span class="varname">to_strip</span> at the end.</div>
<h5><span class="funcname">String.split</span><span><strong>(self: String, split_by: *String=" "):List[String]</strong></span></h5>

<div class="explain">This attempts to split <span class="varname">self</span> using <span class="varname">split_by</span>, with a default value of a single
space.
<br />
Errors:
<br />
Raises <span class="type">ValueError</span> if <span class="varname">split_by</span> is empty.</div>
<h5><span class="funcname">String.starts_with</span><span><strong>(self: String, with: String): Boolean</strong></span></h5>

<div class="explain">Checks if <span class="varname">self</span> starts with <span class="varname">with</span>.</div>
<h5><span class="funcname">String.strip</span><span><strong>(self: String, to_strip: String):String</strong></span></h5>

<div class="explain">This walks through self from right to left, and then from left to right. The
result of this is a newly-made <span class="type">String</span> without any elements within <span class="varname">to_strip</span>
at either end.</div>
<h5><span class="funcname">String.trim</span><span><strong>(self: String): String</strong></span></h5>

<div class="explain">Checks if <span class="varname">self</span> starts or ends with any of <span class="varname">" \t\r\n"</span>. If it does, then a new
<span class="type">String</span> is made with spaces removed from both sides. If it does not, then this
returns <span class="varname">self</span>.</div>
<h5><span class="funcname">String.upper</span><span><strong>(self: String):String</strong></span></h5>

<div class="explain">Checks if any characters within self are within [a-z]. If so, it creates a new
<span class="type">String</span> with [a-z] replaced by [A-Z]. Otherwise, <span class="varname">self</span> is returned.</div>

<h3>Tainted</h3>
<p>The <span class="type">Tainted</span> type represents a wrapper over some data that is considered
unsafe. Data, once inside a <span class="type">Tainted</span> value can only be retrieved using the
<span class="varname">Tainted.sanitize</span> function.</p>
<h5><span class="funcname">Tainted.sanitize</span><span><strong>[A](self: Tainted[A], fn: Function(A => B)): B</strong></span></h5>

<div class="explain">This calls <span class="varname">fn</span> with the value contained within <span class="varname">self</span>. <span class="varname">fn</span> is assumed to be a
function that can sanitize the data within <span class="varname">self</span>.</div>

<h3>Tuple</h3>
<p>The <span class="type">Tuple</span> class provides a fixed-size container over a set of types. <span class="type">Tuple</span>
is ideal for situations where a variety of data is needed, but a class is too
complex.
<br />
<span class="type">Tuple</span> literals are created by <span class="varname">&lt;[value1, value2, ...]&gt;</span>. Member of the <span class="type">Tuple</span>
class can be accessed through subscripts. Unlike <span class="type">List</span>, <span class="type">Tuple</span> does not
support negative indexes.
<br />
Operations on the <span class="type">Tuple</span> class use the types <span class="type">1</span> and <span class="type">2</span>. These are special
types that match against any number of types. This allows <span class="type">Tuple</span> operations to
work on all <span class="type">Tuple</span> instances, regardless of the number of elements within the
<span class="type">Tuple</span> (sometimes considered its arity).</p>
<h5><span class="funcname">Tuple.merge</span><span><strong>(self: Tuple[1], other: Tuple[2]): Tuple[1, 2]</strong></span></h5>

<div class="explain">Build a new <span class="type">Tuple</span> composed of the contents of <span class="varname">self</span> and the contents of
<span class="varname">other</span>.</div>
<h5><span class="funcname">Tuple.push</span><span><strong>[A](self: Tuple[1], other: A): Tuple[1, A]</strong></span></h5>

<div class="explain">Build a new <span class="type">Tuple</span> composed of the contents of <span class="varname">self</span> and <span class="varname">other</span>.</div>
        </div>

        <!-- Bootstrap core JavaScript
        ================================================== -->
        <!-- Placed at the end of the document so the pages load faster -->
        <script src="js/jquery.min.js"></script>
        <script src="js/bootstrap.min.js"></script>
        <script src="js/docs.min.js"></script>
        <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
        <script src="js/ie10-viewport-bug-workaround.js"></script>
    </body>
</html>
